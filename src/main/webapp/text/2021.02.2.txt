사용자 전체 리스트 개발 완료

사용자 페이징 처리 roqkf
페이징 처리를 위해 필요한 값
1. 정렬기준 - userid
2. 페이지 사이즈 - 
3. 페이지
4. user/pagingUser ==> 페이지, 페이지 사이즈 파라미터를 보내지 않음
						페이지, 페이지 사이즈 파라미터가 없을 경우 servlet 기본값 처리를 함
						 1		5
						

RequestParam
**메소드 인자에서 사용가능한 어노테이션
1. 바인딩 될 파라미터 설정(name)
	파라미터 명과 메소드 인자 명이 다를 경우 자동바인딩이 되지 않는 문제를 새결
	파라미터명을 명시함으로써 메소드 인자에 자동 바인딩 될 수 있도록 설정

2. 파라미터가 존재하지 않을 경우 기본 값 설정(defaultValut)
	파라미터가 존재하지 않을 경우, 메소드 인자를 primitive type 으로 선언한 경우 에러 발생
	==>defaultValue 설정으로 에러방지 가능
	
3. 파라미터 존재여부 설정(required, 기본값은 true)
	파라미터가 반드시 필요한지 여부를 설정
	단 default 설정시 자동으로 false로 설정됨



@ModelAttribute -- 사용빈도가 많지는않을것
1. 메소드
	@RequestMapping 어노테이션이 붙은 메소드가 실행되기전에 먼저 실행되고
	해당 메소드가 리턴하는 값을 model객체에 넣어준다
	
	@ModelAttribute
	public list<String> rangers(){
		---
		return list;
	}
	
	@RequestMapping("list")
	public String view(Model model){
		return "view";
	}
	
	localhost/user/list1 ==> rangers() ==> model ==> list
	localhost/user/list2 ==> rangers() ==> model ==> list2
	
	@Before ==> @Test
	@Before ==> @Test
	@Before ==> @Test
	
	3교
2. 파라미터 인자
Model 객체에 저장된속성을 파라미터 인자에 바인딩 가능

command 객체의 경우 @ModelAttribute 어노테이션을 적용하지 않더라도
model 객체에 자동으로 등록이 된다.


@SessionAttribute
class에 적용

@ModelAttribute 가 적용된 메소드가 @RequestMapping이 적용된 메소드 실행 전 항상 호출 되는 부하를
줄이는 것이 목적

최초 1회에 대해서는 @ModelAttribute 가 적용된 메소드를 호출하여 해당 속성 값을 세션에 적용
그 이후 호출에 대해서는 세션에 저장된값을 사용하여 @ModelAttribute 메소드가 적용된 로직이
반복 호출 되는 것을 방지 ==> cache


@PathVariable : uri의 일부를 메소드 인자로 바인딩
리퀘스트uri     /hello/view/user/
이걸 쉽게 하는.

사용 : 메소드 인자
1. @RequestMapping path 설정시 어떤 분을 가져올지 표현
	==>@RequestMapping("hello/{path}") 중괄호
2. @메소드 인자에 @PathVariable을 통해 가져올 값을 바인딩
	public String view (@PathVariable("path") String path){
	
}

@//파람 : 파라미터를 메소드 인자로 바인딩 할 때
@RequestHeader : 헤더 정보를 메소드 인자로 바인딩 할때

파일 업로드시 작업 내역

1.서블릿
	.form 태그 enctype = "multipart/form-data"
	.form 태그 method="post"
	.<input type="file"/>
	.@multipartConfig
	
	파일정보 : Part part = request.getPart();
	
	
2.spring
	.form 태그 enctype = "multipart/form-data"
	.form 태그 method="post"
	.<input type="file"/>
	.**** multipartResolver라는 스프링 번 등록
		//스프링 빈으로 등록한다는건 <bean 이나 @Bean
		conversionService
	commons-fileupload 라이브러리..
	CommonsMultypartResolver라는 스프링 빈 등록 CommonsMultipartResolver
	
	
	파일정보 : MultipartFile
	
	부모 
	자식 (application-context.xml) web.xml에 리스너로 로딩되는게 부모  서블릿에서 인잇파람으로 생성되는게 자식
	그러니까 해당 경로에 추가

@RequestPart - 파일 업로드 : @RequestParam과 유사


@복수파라미터 전송

메소드 인자로 List ==> x List<String> 인자 x
메소드 인자로 배열 ==> o String[]인자 o
메소드 인자로 리스트를 필드로 하는 command 객체 ==> UsersVo usersVo o
	public usersVo {
		private List<String> userids;
		private List<String> usernms; 
	} 
에서 userVo 같은건 됨

사용자 상세조회(이미지 안나와도됨)

스프링 mvc 실습
1. 사용자 상세 페이지(제외 사항 : 사용자 사진x ,  엑스 박스로 떠도 상관없음)
2. 사용자 수정 페이지(파일 업로드까지 전체 이관)
3. 사용자 등록 페이지(파일 업로드까지 전체 이관)
4. 사용자 삭제 기능 (전체 이관)

5. 테스트 코드 작성
